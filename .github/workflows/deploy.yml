# Workflow de CI/CD para deploy da aplicação Couples Financials na AWS
name: Deploy to AWS

on:
  push:
    branches:
      - main
      - production
  workflow_dispatch:

concurrency:
  group: deploy-${{ github.ref_name }}
  cancel-in-progress: false

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: couples-financials
  ECS_SERVICE: couples-financials
  ECS_CLUSTER: couples-financials-cluster
  CONTAINER_NAME: couples-financials

jobs:
  # Job de testes e validação
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'

    - name: Install dependencies
      run: npm ci


    - name: Run linting
      run: npm run lint || true  # Continue mesmo com warnings

    - name: Build application
      run: npm run build

    # Validar se o build foi bem-sucedido
    - name: Validate build output
      run: |
        if [ ! -d "dist" ]; then
          echo "Build failed - dist directory not found"
          exit 1
        fi
        echo "Build successful - dist directory created"

  # Job de build e push da imagem Docker
  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: test
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/production'
    
    outputs:
      image-uri: ${{ steps.build-image.outputs.image }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Create ECR repository if it doesn't exist
      run: |
        aws ecr describe-repositories --repository-names $ECR_REPOSITORY || \
        aws ecr create-repository --repository-name $ECR_REPOSITORY

    - name: Build, tag, and push image to Amazon ECR
      id: build-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Build da imagem Docker
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:latest .
        
        # Push das imagens para ECR
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
        
        # Output da URI da imagem
        echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

    - name: Scan image for vulnerabilities
      run: |
        # Scan de segurança básico da imagem
        aws ecr start-image-scan --repository-name $ECR_REPOSITORY --image-id imageTag=${{ github.sha }} || true

  # Job de deploy na AWS usando Terraform
  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/production'
    
    defaults:
      run:
        working-directory: terraform
        
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0

    - name: Terraform Init
      working-directory: terraform
      run: terraform init

    - name: Terraform Validate
      working-directory: terraform
      run: terraform validate

    - name: Check required secrets
      run: |
        if [ -z "${{ secrets.SUPABASE_ANON_KEY }}" ]; then
          echo "Error: SUPABASE_ANON_KEY secret not set"
          exit 1
        fi
        if [ -z "${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" ]; then
          echo "Error: SUPABASE_SERVICE_ROLE_KEY secret not set"
          exit 1
        fi

    - name: Create terraform.tfvars
      working-directory: terraform
      run: |
        cat > terraform.tfvars << EOF
        aws_region = "${{ env.AWS_REGION }}"
        app_name = "couples-financials"
        environment = "prod"
        container_image = "${{ needs.build-and-push.outputs.image-uri }}"
        supabase_url = "https://elxttabdtddlavhseipz.supabase.co"
        supabase_anon_key = "${{ secrets.SUPABASE_ANON_KEY }}"
        supabase_service_role_key = "${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}"
        EOF

    - name: Terraform Plan
      working-directory: terraform
      run: terraform plan -lock=true -lock-timeout=10m -out=tfplan

    - name: Import existing resources
      working-directory: terraform
      run: |
        # Get account ID
        ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        
        # Import ALB with proper ARN construction
        ALB_ARN=$(aws elbv2 describe-load-balancers --names couples-financials-alb --query 'LoadBalancers[0].LoadBalancerArn' --output text 2>/dev/null || echo "none")
        if [ "$ALB_ARN" != "none" ] && [ "$ALB_ARN" != "None" ]; then
          terraform import aws_lb.app "$ALB_ARN" || true
        fi
        
        # Import Target Group with proper ARN construction
        TG_ARN=$(aws elbv2 describe-target-groups --names couples-financials-tg --query 'TargetGroups[0].TargetGroupArn' --output text 2>/dev/null || echo "none")
        if [ "$TG_ARN" != "none" ] && [ "$TG_ARN" != "None" ]; then
          terraform import aws_lb_target_group.app "$TG_ARN" || true
        fi
        
        # Import ALB Listeners
        if [ "$ALB_ARN" != "none" ] && [ "$ALB_ARN" != "None" ]; then
          # Import HTTP listener (port 80)
          HTTP_LISTENER_ARN=$(aws elbv2 describe-listeners --load-balancer-arn "$ALB_ARN" --query 'Listeners[?Port==`80`].ListenerArn' --output text 2>/dev/null || echo "none")
          if [ "$HTTP_LISTENER_ARN" != "none" ] && [ "$HTTP_LISTENER_ARN" != "None" ]; then
            terraform import aws_lb_listener.app "$HTTP_LISTENER_ARN" || true
          fi
          
          # Import HTTPS listener (port 443) if it exists
          HTTPS_LISTENER_ARN=$(aws elbv2 describe-listeners --load-balancer-arn "$ALB_ARN" --query 'Listeners[?Port==`443`].ListenerArn' --output text 2>/dev/null || echo "none")
          if [ "$HTTPS_LISTENER_ARN" != "none" ] && [ "$HTTPS_LISTENER_ARN" != "None" ]; then
            terraform import 'aws_lb_listener.app_https[0]' "$HTTPS_LISTENER_ARN" || true
          fi
        fi
        
        # Import CloudWatch Log Group
        terraform import aws_cloudwatch_log_group.ecs /ecs/couples-financials || true
        
        # Import ECS Cluster
        terraform import aws_ecs_cluster.app couples-financials-cluster || true
        
        # Import ECS Service
        terraform import aws_ecs_service.app couples-financials-cluster/couples-financials || true
        
        # Import IAM Roles
        terraform import aws_iam_role.ecs_execution_role couples-financials-ecs-execution-role || true
        terraform import aws_iam_role.ecs_task_role couples-financials-ecs-task-role || true
        
        # Import IAM Policy
        POLICY_ARN=$(aws iam list-policies --scope Local --query "Policies[?PolicyName=='couples-financials-secrets-access'].Arn" --output text 2>/dev/null || echo "none")
        if [ "$POLICY_ARN" != "none" ] && [ "$POLICY_ARN" != "None" ]; then
          terraform import aws_iam_policy.secrets_access "$POLICY_ARN" || true
        fi
        
        # Import Secrets
        terraform import aws_secretsmanager_secret.supabase_credentials couples-financials-supabase-credentials || true
        terraform import aws_secretsmanager_secret.app_config couples-financials-app-config || true
        
        # Import CloudFront Function
        terraform import 'aws_cloudfront_function.spa_routing[0]' couples-financials-spa-routing || true

    - name: Terraform Apply
      working-directory: terraform
      if: github.ref == 'refs/heads/main'
      run: |
        terraform apply -lock=true -lock-timeout=10m -auto-approve \
          -var="container_image=${{ needs.build-and-push.outputs.image-uri }}" \
          -var="supabase_anon_key=${{ secrets.SUPABASE_ANON_KEY }}" \
          -var="supabase_service_role_key=${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}"

  # Job de deploy da aplicação no ECS
  deploy-application:
    name: Deploy Application to ECS
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-infrastructure]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/production'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Download task definition
      run: |
        aws ecs describe-task-definition \
          --task-definition ${{ env.ECS_SERVICE }} \
          --query taskDefinition > task-definition.json

    - name: Update task definition with new image
      id: task-def
      uses: aws-actions/amazon-ecs-render-task-definition@v1
      with:
        task-definition: task-definition.json
        container-name: ${{ env.CONTAINER_NAME }}
        image: ${{ needs.build-and-push.outputs.image-uri }}

    - name: Deploy to Amazon ECS
      uses: aws-actions/amazon-ecs-deploy-task-definition@v1
      with:
        task-definition: ${{ steps.task-def.outputs.task-definition }}
        service: ${{ env.ECS_SERVICE }}
        cluster: ${{ env.ECS_CLUSTER }}
        wait-for-service-stability: true

    - name: Verify deployment
      run: |
        # Aguardar a estabilização do serviço
        echo "Waiting for service to stabilize..."
        aws ecs wait services-stable \
          --cluster ${{ env.ECS_CLUSTER }} \
          --services ${{ env.ECS_SERVICE }}
        
        # Verificar status do serviço
        aws ecs describe-services \
          --cluster ${{ env.ECS_CLUSTER }} \
          --services ${{ env.ECS_SERVICE }} \
          --query 'services[0].{ServiceName:serviceName,Status:status,RunningCount:runningCount,DesiredCount:desiredCount}'

  # Job de testes pós-deploy
  post-deploy-tests:
    name: Post-deployment Tests
    runs-on: ubuntu-latest
    needs: deploy-application
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Get application URL
      id: get-url
      run: |
        # Obter URL do Load Balancer
        ALB_DNS=$(aws elbv2 describe-load-balancers \
          --names couples-financials-alb \
          --query 'LoadBalancers[0].DNSName' \
          --output text)
        echo "url=http://$ALB_DNS" >> $GITHUB_OUTPUT

    - name: Health check
      run: |
        # Aguardar alguns segundos para o serviço inicializar
        sleep 30
        
        # Verificar health check
        for i in {1..10}; do
          if curl -f -s "${{ steps.get-url.outputs.url }}/health"; then
            echo "Health check passed!"
            exit 0
          fi
          echo "Health check attempt $i failed, retrying in 30s..."
          sleep 30
        done
        echo "Health check failed after 10 attempts"
        exit 1

    - name: Smoke tests
      run: |
        # Testes básicos de funcionalidade
        URL="${{ steps.get-url.outputs.url }}"
        
        # Verificar se a página principal carrega
        if curl -f -s "$URL" | grep -q "Couples Financials"; then
          echo "✅ Main page loads successfully"
        else
          echo "❌ Main page failed to load"
          exit 1
        fi
        
        echo "🎉 All smoke tests passed!"

  # Job de notificação
  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [deploy-application, post-deploy-tests]
    if: always()
    
    steps:
    - name: Notify success
      if: needs.deploy-application.result == 'success' && needs.post-deploy-tests.result == 'success'
      run: |
        echo "🎉 Deployment successful!"
        echo "Application is now running in production"
        
    - name: Notify failure
      if: needs.deploy-application.result == 'failure' || needs.post-deploy-tests.result == 'failure'
      run: |
        echo "❌ Deployment failed!"
        echo "Check the logs for more details"
        exit 1