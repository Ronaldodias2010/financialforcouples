# Workflow de CI/CD para deploy da aplicação Couples Financials na AWS
name: Deploy to AWS

on:
  push:
    branches:
      - main
      - production
  workflow_dispatch:
    inputs:
      bypass_cloudfront:
        description: 'Bypass CloudFront during deployment'
        required: false
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'
      invalidate_cloudfront:
        description: 'Invalidate CloudFront cache after deployment'
        required: false
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'

concurrency:
  group: deploy-${{ github.ref_name }}
  cancel-in-progress: true

# Configurações globais para resiliência
defaults:
  run:
    shell: bash
    
env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: couples-financials
  ECS_SERVICE: couples-financials
  ECS_CLUSTER: couples-financials-cluster
  CONTAINER_NAME: couples-financials
  # CloudFront bypass for faster deployments
  BYPASS_CLOUDFRONT: ${{ github.event.inputs.bypass_cloudfront || 'true' }}
  # Configurações Git para resiliência
  GIT_CURL_VERBOSE: 1
  GIT_TRACE_CURL: 1
  GIT_HTTP_TIMEOUT: 300

jobs:
  # Job de testes e validação
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    timeout-minutes: 20
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 1
        timeout: 300
      env:
        GIT_CURL_VERBOSE: 1
        GIT_TRACE_CURL: 1

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'yarn'

    - name: Install dependencies
      run: yarn install --no-progress

    - name: Run linting
      run: yarn lint || true  # Continue mesmo com warnings

    - name: Build application
      run: yarn build

    # Validar se o build foi bem-sucedido
    - name: Validate build output
      run: |
        if [ ! -d "dist" ]; then
          echo "Build failed - dist directory not found"
          exit 1
        fi
        echo "Build successful - dist directory created"

  # Job de build e push da imagem Docker
  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    timeout-minutes: 45
    needs: test
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/production'
    
    outputs:
      image-uri: ${{ steps.build-image.outputs.image }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 1
        timeout: 300
      env:
        GIT_CURL_VERBOSE: 1
        GIT_TRACE_CURL: 1

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Create ECR repository if it doesn't exist
      run: |
        aws ecr describe-repositories --repository-names $ECR_REPOSITORY || \
        aws ecr create-repository --repository-name $ECR_REPOSITORY

    - name: Build, tag, and push image to Amazon ECR
      id: build-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Build da imagem Docker
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:latest .
        
        # Push das imagens para ECR
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
        
        # Output da URI da imagem
        echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

    - name: Scan image for vulnerabilities
      run: |
        # Scan de segurança básico da imagem
        aws ecr start-image-scan --repository-name $ECR_REPOSITORY --image-id imageTag=${{ github.sha }} || true

  # Job de deploy na AWS usando Terraform
  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    timeout-minutes: 45
    needs: build-and-push
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/production'
    
    defaults:
      run:
        working-directory: terraform
        
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 1
        timeout: 300
      env:
        GIT_CURL_VERBOSE: 1
        GIT_TRACE_CURL: 1

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0

    - name: Terraform Init
      working-directory: terraform
      run: terraform init

    - name: Terraform Validate
      working-directory: terraform
      run: terraform validate

    - name: Check required secrets
      run: |
        if [ -z "${{ secrets.SUPABASE_ANON_KEY }}" ]; then
          echo "Error: SUPABASE_ANON_KEY secret not set"
          exit 1
        fi
        if [ -z "${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" ]; then
          echo "Error: SUPABASE_SERVICE_ROLE_KEY secret not set"
          exit 1
        fi

    - name: Create terraform.tfvars
      working-directory: terraform
      run: |
        cat > terraform.tfvars << EOF
        aws_region = "${{ env.AWS_REGION }}"
        app_name = "couples-financials"
        environment = "prod"
        container_image = "${{ needs.build-and-push.outputs.image-uri }}"
        supabase_url = "https://elxttabdtddlavhseipz.supabase.co"
        supabase_anon_key = "${{ secrets.SUPABASE_ANON_KEY }}"
        supabase_service_role_key = "${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}"
        cloudfront_oac_id = "${{ secrets.CLOUDFRONT_OAC_ID }}"
        cloudfront_create_spa_function = false
        enable_cloudfront = ${{ env.BYPASS_CLOUDFRONT == 'false' }}
        EOF
        if [ -z "${{ secrets.CLOUDFRONT_OAC_ID }}" ]; then
          echo "Note: CLOUDFRONT_OAC_ID not set; Terraform will attempt to create a new OAC."
        else
          echo "Using existing CloudFront OAC ID from secret."
        fi

    - name: Terraform Plan
      working-directory: terraform
      run: terraform plan -lock=true -lock-timeout=10m -out=tfplan

    - name: Import critical resources only
      working-directory: terraform
      run: |
         echo "Importing existing AWS resources to avoid recreation..."
         
         # ECS Cluster
         terraform import aws_ecs_cluster.main couples-financials-cluster || true
         
         # CloudWatch Log Group
         terraform import aws_cloudwatch_log_group.ecs /ecs/couples-financials || true
         
         # Application Load Balancer (needs ARN)
         ALB_ARN=$(aws elbv2 describe-load-balancers \
           --names couples-financials-alb \
           --query 'LoadBalancers[0].LoadBalancerArn' \
           --output text 2>/dev/null || true)
         if [ -n "$ALB_ARN" ] && [ "$ALB_ARN" != "None" ]; then
           terraform import aws_lb.app "$ALB_ARN" || true

           # Import HTTP listener (port 80)
           LISTENER80_ARN=$(aws elbv2 describe-listeners \
             --load-balancer-arn "$ALB_ARN" \
             --query 'Listeners[?Port==`80`].ListenerArn' \
             --output text 2>/dev/null || true)
           if [ -n "$LISTENER80_ARN" ] && [ "$LISTENER80_ARN" != "None" ]; then
             terraform import aws_lb_listener.app "$LISTENER80_ARN" || true
           fi
         fi

         # Target Group (needs ARN)
         TG_ARN=$(aws elbv2 describe-target-groups \
           --names couples-financials-tg \
           --query 'TargetGroups[0].TargetGroupArn' \
           --output text 2>/dev/null || true)
         if [ -n "$TG_ARN" ] && [ "$TG_ARN" != "None" ]; then
           terraform import aws_lb_target_group.app "$TG_ARN" || true
         fi

         # ECS Service
         terraform import aws_ecs_service.app couples-financials-cluster/couples-financials || true

         # IAM Roles
         terraform import aws_iam_role.ecs_execution_role couples-financials-ecs-execution-role || true
         terraform import aws_iam_role.ecs_task_role couples-financials-ecs-task-role || true

         # IAM Managed Policy for secrets access
         ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text 2>/dev/null || true)
         if [ -n "$ACCOUNT_ID" ]; then
           POLICY_ARN="arn:aws:iam::$ACCOUNT_ID:policy/couples-financials-secrets-access"
           terraform import aws_iam_policy.secrets_access "$POLICY_ARN" || true
           terraform import aws_iam_role_policy_attachment.ecs_secrets_access "couples-financials-ecs-execution-role/$POLICY_ARN" || true
         fi

         # Secrets Manager Secrets
         terraform import aws_secretsmanager_secret.supabase_credentials couples-financials-supabase-credentials || true
         terraform import aws_secretsmanager_secret.app_config couples-financials-app-config || true

         echo "Import step finished"

    - name: Terraform Apply
      working-directory: terraform
      if: github.ref == 'refs/heads/main'
      run: |
        set -e
        ENABLE_CF="${{ env.BYPASS_CLOUDFRONT == 'false' }}"
        echo "BYPASS_CLOUDFRONT=${{ env.BYPASS_CLOUDFRONT }} -> enable_cloudfront=$ENABLE_CF"
        if [ "$ENABLE_CF" = "true" ]; then
          echo "Attempting apply with CloudFront enabled..."
          set +e
          terraform apply -lock=true -lock-timeout=10m -auto-approve \
            -var="container_image=${{ needs.build-and-push.outputs.image-uri }}" \
            -var="supabase_anon_key=${{ secrets.SUPABASE_ANON_KEY }}" \
            -var="supabase_service_role_key=${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" \
            -var="cloudfront_oac_id=${{ secrets.CLOUDFRONT_OAC_ID }}" \
            -var="cloudfront_create_spa_function=false" \
            -var="enable_cloudfront=true" 2>&1 | tee apply.log
          APPLY_EXIT=${PIPESTATUS[0]}
          set -e
          if grep -q "TooManyDistributions" apply.log; then
            echo "CloudFront quota exceeded. Falling back to ALB-only deployment..."
            terraform apply -lock=true -lock-timeout=10m -auto-approve \
              -var="container_image=${{ needs.build-and-push.outputs.image-uri }}" \
              -var="supabase_anon_key=${{ secrets.SUPABASE_ANON_KEY }}" \
              -var="supabase_service_role_key=${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" \
              -var="cloudfront_oac_id=${{ secrets.CLOUDFRONT_OAC_ID }}" \
              -var="cloudfront_create_spa_function=false" \
              -var="enable_cloudfront=false"
          elif [ $APPLY_EXIT -ne 0 ]; then
            echo "Terraform apply failed. See logs above."
            exit $APPLY_EXIT
          fi
        else 
          echo "Bypass enabled. Applying without CloudFront..."
          terraform apply -lock=true -lock-timeout=10m -auto-approve \
            -var="container_image=${{ needs.build-and-push.outputs.image-uri }}" \
            -var="supabase_anon_key=${{ secrets.SUPABASE_ANON_KEY }}" \
            -var="supabase_service_role_key=${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" \
            -var="cloudfront_oac_id=${{ secrets.CLOUDFRONT_OAC_ID }}" \
            -var="cloudfront_create_spa_function=false" \
            -var="enable_cloudfront=false"
        fi

  # Job de deploy da aplicação no ECS
  deploy-application:
    name: Deploy Application to ECS
    runs-on: ubuntu-latest
    timeout-minutes: 45
    needs: [build-and-push, deploy-infrastructure]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/production'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 1
        timeout: 300
      env:
        GIT_CURL_VERBOSE: 1
        GIT_TRACE_CURL: 1

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Download task definition
      run: |
        aws ecs describe-task-definition \
          --task-definition ${{ env.ECS_SERVICE }} \
          --query taskDefinition > task-definition.json

    - name: Update task definition with new image
      id: task-def
      uses: aws-actions/amazon-ecs-render-task-definition@v1
      with:
        task-definition: task-definition.json
        container-name: ${{ env.CONTAINER_NAME }}
        image: ${{ needs.build-and-push.outputs.image-uri }}

    - name: Deploy to Amazon ECS
      uses: aws-actions/amazon-ecs-deploy-task-definition@v1
      with:
        task-definition: ${{ steps.task-def.outputs.task-definition }}
        service: ${{ env.ECS_SERVICE }}
        cluster: ${{ env.ECS_CLUSTER }}
        wait-for-service-stability: true

    - name: Verify deployment
      run: |
        # Aguardar a estabilização do serviço
        echo "Waiting for service to stabilize..."
        aws ecs wait services-stable \
          --cluster ${{ env.ECS_CLUSTER }} \
          --services ${{ env.ECS_SERVICE }}
        
        # Verificar status do serviço
        aws ecs describe-services \
          --cluster ${{ env.ECS_CLUSTER }} \
          --services ${{ env.ECS_SERVICE }} \
          --query 'services[0].{ServiceName:serviceName,Status:status,RunningCount:runningCount,DesiredCount:desiredCount}'

  # Job de testes pós-deploy
  post-deploy-tests:
    name: Post-deployment Tests
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: deploy-application
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Get application URLs
      id: get-url
      run: |
        # Obter URL do Load Balancer (direto)
        ALB_DNS=$(aws elbv2 describe-load-balancers \
          --names couples-financials-alb \
          --query 'LoadBalancers[0].DNSName' \
          --output text)
        echo "alb_url=http://$ALB_DNS" >> $GITHUB_OUTPUT
        
        # Obter URL do CloudFront (se habilitado)
        if [ "${{ env.BYPASS_CLOUDFRONT }}" == "false" ]; then
          CLOUDFRONT_DOMAIN=$(aws cloudfront list-distributions \
            --query "DistributionList.Items[?contains(Comment, 'couples-financials')].DomainName" \
            --output text | head -1)
          if [ -n "$CLOUDFRONT_DOMAIN" ] && [ "$CLOUDFRONT_DOMAIN" != "None" ]; then
            echo "cloudfront_url=https://$CLOUDFRONT_DOMAIN" >> $GITHUB_OUTPUT
            echo "url=https://$CLOUDFRONT_DOMAIN" >> $GITHUB_OUTPUT
          else
            echo "url=http://$ALB_DNS" >> $GITHUB_OUTPUT
          fi
        else
          echo "url=http://$ALB_DNS" >> $GITHUB_OUTPUT
        fi

    - name: Health check
      run: |
        # Aguardar alguns segundos para o serviço inicializar
        sleep 30
        
        # Verificar health check
        for i in {1..10}; do
          if curl -f -s "${{ steps.get-url.outputs.url }}/health"; then
            echo "Health check passed!"
            exit 0
          fi
          echo "Health check attempt $i failed, retrying in 30s..."
          sleep 30
        done
        echo "Health check failed after 10 attempts"
        exit 1

    - name: Smoke tests
      run: |
        # Testes básicos de funcionalidade
        URL="${{ steps.get-url.outputs.url }}"
        
        # Verificar se a página principal carrega
        if curl -f -s "$URL" | grep -q "Couples Financials"; then
          echo "✅ Main page loads successfully"
        else
          echo "❌ Main page failed to load"
          exit 1
        fi
        
        echo "🎉 All smoke tests passed!"
        
        # Mostrar URLs disponíveis
        echo "📍 Application URLs:"
        echo "   ALB (direct): ${{ steps.get-url.outputs.alb_url }}"
        if [ -n "${{ steps.get-url.outputs.cloudfront_url }}" ]; then
          echo "   CloudFront: ${{ steps.get-url.outputs.cloudfront_url }}"
        fi

    - name: Invalidate CloudFront cache
      if: env.BYPASS_CLOUDFRONT == 'false' && github.event.inputs.invalidate_cloudfront == 'true'
      run: |
        # Invalidar cache do CloudFront
        DISTRIBUTION_ID=$(aws cloudfront list-distributions \
          --query "DistributionList.Items[?contains(Comment, 'couples-financials')].Id" \
          --output text | head -1)
        
        if [ -n "$DISTRIBUTION_ID" ] && [ "$DISTRIBUTION_ID" != "None" ]; then
          echo "Invalidating CloudFront cache for distribution: $DISTRIBUTION_ID"
          aws cloudfront create-invalidation \
            --distribution-id "$DISTRIBUTION_ID" \
            --paths "/*"
          echo "✅ CloudFront cache invalidated"
        else
          echo "⚠️  CloudFront distribution not found"
        fi

  # Job de notificação
  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [deploy-application, post-deploy-tests]
    if: always()
    
    steps:
    - name: Notify success
      if: needs.deploy-application.result == 'success' && needs.post-deploy-tests.result == 'success'
      run: |
        echo "🎉 Deployment successful!"
        echo "Application is now running in production"
        
    - name: Notify failure
      if: needs.deploy-application.result == 'failure' || needs.post-deploy-tests.result == 'failure'
      run: |
        echo "❌ Deployment failed!"
        echo "Check the logs for more details"
        exit 1