# Workflow de CI/CD para deploy da aplicação Couples Financials na AWS
name: Deploy to AWS

on:
  push:
    branches:
      - main
      - production
  workflow_dispatch:

concurrency:
  group: deploy-${{ github.ref_name }}
  cancel-in-progress: true

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: couples-financials
  ECS_SERVICE: couples-financials
  ECS_CLUSTER: couples-financials-cluster
  CONTAINER_NAME: couples-financials

jobs:
  # Job de testes e validação
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    timeout-minutes: 20
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'yarn'

    - name: Install dependencies
      run: yarn install --no-progress

    - name: Run linting
      run: yarn lint || true  # Continue mesmo com warnings

    - name: Build application
      run: yarn build

    # Validar se o build foi bem-sucedido
    - name: Validate build output
      run: |
        if [ ! -d "dist" ]; then
          echo "Build failed - dist directory not found"
          exit 1
        fi
        echo "Build successful - dist directory created"

  # Job de build e push da imagem Docker
  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    timeout-minutes: 45
    needs: test
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/production'
    
    outputs:
      image-uri: ${{ steps.build-image.outputs.image }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Create ECR repository if it doesn't exist
      run: |
        aws ecr describe-repositories --repository-names $ECR_REPOSITORY || \
        aws ecr create-repository --repository-name $ECR_REPOSITORY

    - name: Build, tag, and push image to Amazon ECR
      id: build-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Build da imagem Docker
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:latest .
        
        # Push das imagens para ECR
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
        
        # Output da URI da imagem
        echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

    - name: Scan image for vulnerabilities
      run: |
        # Scan de segurança básico da imagem
        aws ecr start-image-scan --repository-name $ECR_REPOSITORY --image-id imageTag=${{ github.sha }} || true

  # Job de deploy na AWS usando Terraform
  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    timeout-minutes: 45
    needs: build-and-push
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/production'
    
    defaults:
      run:
        working-directory: terraform
        
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0

    - name: Terraform Init
      working-directory: terraform
      run: terraform init

    - name: Terraform Validate
      working-directory: terraform
      run: terraform validate

    - name: Check required secrets
      run: |
        if [ -z "${{ secrets.SUPABASE_ANON_KEY }}" ]; then
          echo "Error: SUPABASE_ANON_KEY secret not set"
          exit 1
        fi
        if [ -z "${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" ]; then
          echo "Error: SUPABASE_SERVICE_ROLE_KEY secret not set"
          exit 1
        fi

    - name: Create terraform.tfvars
      working-directory: terraform
      run: |
        cat > terraform.tfvars << EOF
        aws_region = "${{ env.AWS_REGION }}"
        app_name = "couples-financials"
        environment = "prod"
        container_image = "${{ needs.build-and-push.outputs.image-uri }}"
        supabase_url = "https://elxttabdtddlavhseipz.supabase.co"
        supabase_anon_key = "${{ secrets.SUPABASE_ANON_KEY }}"
        supabase_service_role_key = "${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}"
        cloudfront_oac_id = "${{ secrets.CLOUDFRONT_OAC_ID }}"
        cloudfront_create_spa_function = false
        EOF
        if [ -z "${{ secrets.CLOUDFRONT_OAC_ID }}" ]; then
          echo "Note: CLOUDFRONT_OAC_ID not set; Terraform will attempt to create a new OAC."
        else
          echo "Using existing CloudFront OAC ID from secret."
        fi

    - name: Terraform Plan
      working-directory: terraform
      run: terraform plan -lock=true -lock-timeout=10m -out=tfplan

    - name: Import critical resources only
      working-directory: terraform
      run: |
        echo "Importing only essential resources to avoid timeouts..."
        
        # Import ECS Cluster (essential)
        terraform import aws_ecs_cluster.app couples-financials-cluster || true
        
        # Import CloudWatch Log Group (essential)
        terraform import aws_cloudwatch_log_group.ecs /ecs/couples-financials || true
        
        echo "Critical imports completed"

    - name: Terraform Apply
      working-directory: terraform
      if: github.ref == 'refs/heads/main'
      run: |
        terraform apply -lock=true -lock-timeout=10m -auto-approve \
          -var="container_image=${{ needs.build-and-push.outputs.image-uri }}" \
          -var="supabase_anon_key=${{ secrets.SUPABASE_ANON_KEY }}" \
          -var="supabase_service_role_key=${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" \
          -var="cloudfront_oac_id=${{ secrets.CLOUDFRONT_OAC_ID }}" \
          -var="cloudfront_create_spa_function=false"

  # Job de deploy da aplicação no ECS
  deploy-application:
    name: Deploy Application to ECS
    runs-on: ubuntu-latest
    timeout-minutes: 45
    needs: [build-and-push, deploy-infrastructure]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/production'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Download task definition
      run: |
        aws ecs describe-task-definition \
          --task-definition ${{ env.ECS_SERVICE }} \
          --query taskDefinition > task-definition.json

    - name: Update task definition with new image
      id: task-def
      uses: aws-actions/amazon-ecs-render-task-definition@v1
      with:
        task-definition: task-definition.json
        container-name: ${{ env.CONTAINER_NAME }}
        image: ${{ needs.build-and-push.outputs.image-uri }}

    - name: Deploy to Amazon ECS
      uses: aws-actions/amazon-ecs-deploy-task-definition@v1
      with:
        task-definition: ${{ steps.task-def.outputs.task-definition }}
        service: ${{ env.ECS_SERVICE }}
        cluster: ${{ env.ECS_CLUSTER }}
        wait-for-service-stability: true

    - name: Verify deployment
      run: |
        # Aguardar a estabilização do serviço
        echo "Waiting for service to stabilize..."
        aws ecs wait services-stable \
          --cluster ${{ env.ECS_CLUSTER }} \
          --services ${{ env.ECS_SERVICE }}
        
        # Verificar status do serviço
        aws ecs describe-services \
          --cluster ${{ env.ECS_CLUSTER }} \
          --services ${{ env.ECS_SERVICE }} \
          --query 'services[0].{ServiceName:serviceName,Status:status,RunningCount:runningCount,DesiredCount:desiredCount}'

  # Job de testes pós-deploy
  post-deploy-tests:
    name: Post-deployment Tests
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: deploy-application
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Get application URL
      id: get-url
      run: |
        # Obter URL do Load Balancer
        ALB_DNS=$(aws elbv2 describe-load-balancers \
          --names couples-financials-alb \
          --query 'LoadBalancers[0].DNSName' \
          --output text)
        echo "url=http://$ALB_DNS" >> $GITHUB_OUTPUT

    - name: Health check
      run: |
        # Aguardar alguns segundos para o serviço inicializar
        sleep 30
        
        # Verificar health check
        for i in {1..10}; do
          if curl -f -s "${{ steps.get-url.outputs.url }}/health"; then
            echo "Health check passed!"
            exit 0
          fi
          echo "Health check attempt $i failed, retrying in 30s..."
          sleep 30
        done
        echo "Health check failed after 10 attempts"
        exit 1

    - name: Smoke tests
      run: |
        # Testes básicos de funcionalidade
        URL="${{ steps.get-url.outputs.url }}"
        
        # Verificar se a página principal carrega
        if curl -f -s "$URL" | grep -q "Couples Financials"; then
          echo "✅ Main page loads successfully"
        else
          echo "❌ Main page failed to load"
          exit 1
        fi
        
        echo "🎉 All smoke tests passed!"

  # Job de notificação
  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [deploy-application, post-deploy-tests]
    if: always()
    
    steps:
    - name: Notify success
      if: needs.deploy-application.result == 'success' && needs.post-deploy-tests.result == 'success'
      run: |
        echo "🎉 Deployment successful!"
        echo "Application is now running in production"
        
    - name: Notify failure
      if: needs.deploy-application.result == 'failure' || needs.post-deploy-tests.result == 'failure'
      run: |
        echo "❌ Deployment failed!"
        echo "Check the logs for more details"
        exit 1